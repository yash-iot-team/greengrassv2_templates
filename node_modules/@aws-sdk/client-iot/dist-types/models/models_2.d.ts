import { MetadataBearer as $MetadataBearer, SmithyException as __SmithyException } from "@aws-sdk/types";
import { AbortConfig, AggregationType, AlertTarget, AttributePayload, AuditCheckConfiguration, AuditFrequency, AuditMitigationActionsTaskTarget, AuditNotificationTarget, AuthInfo, AuthorizerConfig, AuthorizerStatus, AuthResult, AutoRegistrationStatus, Behavior, BillingGroupProperties, CustomMetricType, DayOfWeek, DimensionType, FleetMetricUnit, JobExecutionsRetryConfig, JobExecutionsRolloutConfig, LogLevel, MetricToRetain, MetricValue, MitigationActionParams, PresignedUrlConfig, ProvisioningHook, ResourceIdentifier, StreamFile, Tag, ThingGroupProperties, ThingTypeProperties, TimeoutConfig, TopicRuleDestinationStatus, TopicRulePayload, VerificationState, ViolationEventAdditionalInfo } from "./models_0";
import { BehaviorCriteriaType, CACertificateStatus, CertificateStatus, Configuration, DetectMitigationActionsTaskTarget, DomainConfigurationStatus, LogTargetType, RegistrationConfig, ReportType, Status, ThingGroupIndexingConfiguration, ThingIndexingConfiguration, ThingTypeMetadata, ViolationEventOccurrenceRange } from "./models_1";
export interface ListThingRegistrationTaskReportsRequest {
    /**
     * <p>The id of the task.</p>
     */
    taskId: string | undefined;
    /**
     * <p>The type of task report.</p>
     */
    reportType: ReportType | string | undefined;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 		the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return per request.</p>
     */
    maxResults?: number;
}
export declare namespace ListThingRegistrationTaskReportsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingRegistrationTaskReportsRequest) => any;
}
export interface ListThingRegistrationTaskReportsResponse {
    /**
     * <p>Links to the task resources.</p>
     */
    resourceLinks?: string[];
    /**
     * <p>The type of task report.</p>
     */
    reportType?: ReportType | string;
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingRegistrationTaskReportsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingRegistrationTaskReportsResponse) => any;
}
export interface ListThingRegistrationTasksRequest {
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 			the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
    /**
     * <p>The status of the bulk thing provisioning task.</p>
     */
    status?: Status | string;
}
export declare namespace ListThingRegistrationTasksRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingRegistrationTasksRequest) => any;
}
export interface ListThingRegistrationTasksResponse {
    /**
     * <p>A list of bulk thing provisioning task IDs.</p>
     */
    taskIds?: string[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingRegistrationTasksResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingRegistrationTasksResponse) => any;
}
/**
 * <p>The input for the ListThings operation.</p>
 */
export interface ListThingsRequest {
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 			the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return in this operation.</p>
     */
    maxResults?: number;
    /**
     * <p>The attribute name used to search for things.</p>
     */
    attributeName?: string;
    /**
     * <p>The attribute value used to search for things.</p>
     */
    attributeValue?: string;
    /**
     * <p>The name of the thing type used to search for things.</p>
     */
    thingTypeName?: string;
    /**
     * <p>When <code>true</code>, the action returns the thing resources with attribute values
     *                      that start with the <code>attributeValue</code> provided.</p>
     *             <p>When <code>false</code>, or not present, the action returns only the thing
     * 			resources with attribute values that match the entire <code>attributeValue</code>
     * 			provided. </p>
     */
    usePrefixAttributeValue?: boolean;
}
export declare namespace ListThingsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsRequest) => any;
}
/**
 * <p>The properties of the thing, including thing name, thing type name, and a list of thing
 * 			attributes.</p>
 */
export interface ThingAttribute {
    /**
     * <p>The name of the thing.</p>
     */
    thingName?: string;
    /**
     * <p>The name of the thing type, if the thing has been associated with a type.</p>
     */
    thingTypeName?: string;
    /**
     * <p>The thing ARN.</p>
     */
    thingArn?: string;
    /**
     * <p>A list of thing attributes which are name-value pairs.</p>
     */
    attributes?: {
        [key: string]: string;
    };
    /**
     * <p>The version of the thing record in the registry.</p>
     */
    version?: number;
}
export declare namespace ThingAttribute {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ThingAttribute) => any;
}
/**
 * <p>The output from the ListThings operation.</p>
 */
export interface ListThingsResponse {
    /**
     * <p>The things.</p>
     */
    things?: ThingAttribute[];
    /**
     * <p>The token to use to get the next set of results. Will not be returned if operation has returned all results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsResponse) => any;
}
export interface ListThingsInBillingGroupRequest {
    /**
     * <p>The name of the billing group.</p>
     */
    billingGroupName: string | undefined;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 			the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return per request.</p>
     */
    maxResults?: number;
}
export declare namespace ListThingsInBillingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsInBillingGroupRequest) => any;
}
export interface ListThingsInBillingGroupResponse {
    /**
     * <p>A list of things in the billing group.</p>
     */
    things?: string[];
    /**
     * <p>The token to use to get the next set of results. Will not be returned if operation has returned all results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingsInBillingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsInBillingGroupResponse) => any;
}
export interface ListThingsInThingGroupRequest {
    /**
     * <p>The thing group name.</p>
     */
    thingGroupName: string | undefined;
    /**
     * <p>When true, list things in this thing group and in all child groups as
     * 			well.</p>
     */
    recursive?: boolean;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 			the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
}
export declare namespace ListThingsInThingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsInThingGroupRequest) => any;
}
export interface ListThingsInThingGroupResponse {
    /**
     * <p>The things in the specified thing group.</p>
     */
    things?: string[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingsInThingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingsInThingGroupResponse) => any;
}
/**
 * <p>The input for the ListThingTypes operation.</p>
 */
export interface ListThingTypesRequest {
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     * 			value from a previous response; otherwise <b>null</b> to receive
     * 			the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return in this operation.</p>
     */
    maxResults?: number;
    /**
     * <p>The name of the thing type.</p>
     */
    thingTypeName?: string;
}
export declare namespace ListThingTypesRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingTypesRequest) => any;
}
/**
 * <p>The definition of the thing type, including thing type name and description.</p>
 */
export interface ThingTypeDefinition {
    /**
     * <p>The name of the thing type.</p>
     */
    thingTypeName?: string;
    /**
     * <p>The thing type ARN.</p>
     */
    thingTypeArn?: string;
    /**
     * <p>The ThingTypeProperties for the thing type.</p>
     */
    thingTypeProperties?: ThingTypeProperties;
    /**
     * <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and
     * 			time, a value indicating whether the thing type is deprecated, and a date and time when it was
     * 			deprecated.</p>
     */
    thingTypeMetadata?: ThingTypeMetadata;
}
export declare namespace ThingTypeDefinition {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ThingTypeDefinition) => any;
}
/**
 * <p>The output for the ListThingTypes operation.</p>
 */
export interface ListThingTypesResponse {
    /**
     * <p>The thing types.</p>
     */
    thingTypes?: ThingTypeDefinition[];
    /**
     * <p>The token for the next set of results. Will not be returned if operation has returned all results.</p>
     */
    nextToken?: string;
}
export declare namespace ListThingTypesResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListThingTypesResponse) => any;
}
export interface ListTopicRuleDestinationsRequest {
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     *          value from a previous response; otherwise <b>null</b> to receive
     *          the first set of results.</p>
     */
    nextToken?: string;
}
export declare namespace ListTopicRuleDestinationsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTopicRuleDestinationsRequest) => any;
}
/**
 * <p>Information about an HTTP URL destination.</p>
 */
export interface HttpUrlDestinationSummary {
    /**
     * <p>The URL used to confirm ownership of or access to the HTTP topic rule destination
     *          URL.</p>
     */
    confirmationUrl?: string;
}
export declare namespace HttpUrlDestinationSummary {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: HttpUrlDestinationSummary) => any;
}
/**
 * <p>The summary of a virtual private cloud (VPC) destination.</p>
 */
export interface VpcDestinationSummary {
    /**
     * <p>The subnet IDs of the VPC destination.</p>
     */
    subnetIds?: string[];
    /**
     * <p>The security groups of the VPC destination.</p>
     */
    securityGroups?: string[];
    /**
     * <p>The ID of the VPC.</p>
     */
    vpcId?: string;
    /**
     * <p>The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).</p>
     */
    roleArn?: string;
}
export declare namespace VpcDestinationSummary {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: VpcDestinationSummary) => any;
}
/**
 * <p>Information about the topic rule destination.</p>
 */
export interface TopicRuleDestinationSummary {
    /**
     * <p>The topic rule destination ARN.</p>
     */
    arn?: string;
    /**
     * <p>The status of the topic rule destination. Valid values are:</p>
     *          <dl>
     *             <dt>IN_PROGRESS</dt>
     *             <dd>
     *                <p>A topic rule destination was created but has not been confirmed. You can set
     *                      <code>status</code> to <code>IN_PROGRESS</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>. Calling
     *                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
     *                   be sent to your confirmation endpoint.</p>
     *             </dd>
     *             <dt>ENABLED</dt>
     *             <dd>
     *                <p>Confirmation was completed, and traffic to this destination is allowed. You can
     *                   set <code>status</code> to <code>DISABLED</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>.</p>
     *             </dd>
     *             <dt>DISABLED</dt>
     *             <dd>
     *                <p>Confirmation was completed, and traffic to this destination is not allowed. You
     *                   can set <code>status</code> to <code>ENABLED</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>.</p>
     *             </dd>
     *             <dt>ERROR</dt>
     *             <dd>
     *                <p>Confirmation could not be completed, for example if the confirmation timed out.
     *                   You can call <code>GetTopicRuleDestination</code> for details about the error. You
     *                   can set <code>status</code> to <code>IN_PROGRESS</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>. Calling
     *                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
     *                   be sent to your confirmation endpoint.</p>
     *             </dd>
     *          </dl>
     */
    status?: TopicRuleDestinationStatus | string;
    /**
     * <p>The date and time when the topic rule destination was created.</p>
     */
    createdAt?: Date;
    /**
     * <p>The date and time when the topic rule destination was last updated.</p>
     */
    lastUpdatedAt?: Date;
    /**
     * <p>The reason the topic rule destination is in the current status.</p>
     */
    statusReason?: string;
    /**
     * <p>Information about the HTTP URL.</p>
     */
    httpUrlSummary?: HttpUrlDestinationSummary;
    /**
     * <p>Information about the virtual private cloud (VPC) connection.</p>
     */
    vpcDestinationSummary?: VpcDestinationSummary;
}
export declare namespace TopicRuleDestinationSummary {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TopicRuleDestinationSummary) => any;
}
export interface ListTopicRuleDestinationsResponse {
    /**
     * <p>Information about a topic rule destination.</p>
     */
    destinationSummaries?: TopicRuleDestinationSummary[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListTopicRuleDestinationsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTopicRuleDestinationsResponse) => any;
}
/**
 * <p>The input for the ListTopicRules operation.</p>
 */
export interface ListTopicRulesRequest {
    /**
     * <p>The topic.</p>
     */
    topic?: string;
    /**
     * <p>The maximum number of results to return.</p>
     */
    maxResults?: number;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     *          value from a previous response; otherwise <b>null</b> to receive
     *          the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>Specifies whether the rule is disabled.</p>
     */
    ruleDisabled?: boolean;
}
export declare namespace ListTopicRulesRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTopicRulesRequest) => any;
}
/**
 * <p>Describes a rule.</p>
 */
export interface TopicRuleListItem {
    /**
     * <p>The rule ARN.</p>
     */
    ruleArn?: string;
    /**
     * <p>The name of the rule.</p>
     */
    ruleName?: string;
    /**
     * <p>The pattern for the topic names that apply.</p>
     */
    topicPattern?: string;
    /**
     * <p>The date and time the rule was created.</p>
     */
    createdAt?: Date;
    /**
     * <p>Specifies whether the rule is disabled.</p>
     */
    ruleDisabled?: boolean;
}
export declare namespace TopicRuleListItem {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TopicRuleListItem) => any;
}
/**
 * <p>The output from the ListTopicRules operation.</p>
 */
export interface ListTopicRulesResponse {
    /**
     * <p>The rules.</p>
     */
    rules?: TopicRuleListItem[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListTopicRulesResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTopicRulesResponse) => any;
}
export interface ListV2LoggingLevelsRequest {
    /**
     * <p>The type of resource for which you are configuring logging. Must be
     *             <code>THING_Group</code>.</p>
     */
    targetType?: LogTargetType | string;
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     *          value from a previous response; otherwise <b>null</b> to receive
     *          the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
}
export declare namespace ListV2LoggingLevelsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListV2LoggingLevelsRequest) => any;
}
/**
 * <p>A log target.</p>
 */
export interface LogTarget {
    /**
     * <p>The target type.</p>
     */
    targetType: LogTargetType | string | undefined;
    /**
     * <p>The target name.</p>
     */
    targetName?: string;
}
export declare namespace LogTarget {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: LogTarget) => any;
}
/**
 * <p>The target configuration.</p>
 */
export interface LogTargetConfiguration {
    /**
     * <p>A log target</p>
     */
    logTarget?: LogTarget;
    /**
     * <p>The logging level.</p>
     */
    logLevel?: LogLevel | string;
}
export declare namespace LogTargetConfiguration {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: LogTargetConfiguration) => any;
}
export interface ListV2LoggingLevelsResponse {
    /**
     * <p>The logging configuration for a target.</p>
     */
    logTargetConfigurations?: LogTargetConfiguration[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListV2LoggingLevelsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListV2LoggingLevelsResponse) => any;
}
export interface ListViolationEventsRequest {
    /**
     * <p>The start time for the alerts to be listed.</p>
     */
    startTime: Date | undefined;
    /**
     * <p>The end time for the alerts to be listed.</p>
     */
    endTime: Date | undefined;
    /**
     * <p>A filter to limit results to those alerts caused by the specified thing.</p>
     */
    thingName?: string;
    /**
     * <p>A filter to limit results to those alerts generated by the specified security profile.</p>
     */
    securityProfileName?: string;
    /**
     * <p>
     *       The criteria for a behavior.
     *     </p>
     */
    behaviorCriteriaType?: BehaviorCriteriaType | string;
    /**
     * <p>
     *       A list of all suppressed alerts.
     *     </p>
     */
    listSuppressedAlerts?: boolean;
    /**
     * <p>The verification state of the violation (detect alarm).</p>
     */
    verificationState?: VerificationState | string;
    /**
     * <p>The token for the next set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
}
export declare namespace ListViolationEventsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListViolationEventsRequest) => any;
}
export declare enum ViolationEventType {
    ALARM_CLEARED = "alarm-cleared",
    ALARM_INVALIDATED = "alarm-invalidated",
    IN_ALARM = "in-alarm"
}
/**
 * <p>Information about a Device Defender security profile behavior violation.</p>
 */
export interface ViolationEvent {
    /**
     * <p>The ID of the violation event.</p>
     */
    violationId?: string;
    /**
     * <p>The name of the thing responsible for the violation event.</p>
     */
    thingName?: string;
    /**
     * <p>The name of the security profile whose behavior was violated.</p>
     */
    securityProfileName?: string;
    /**
     * <p>The behavior that was violated.</p>
     */
    behavior?: Behavior;
    /**
     * <p>The value of the metric (the measurement).</p>
     */
    metricValue?: MetricValue;
    /**
     * <p>
     *             The details of a violation event.
     *         </p>
     */
    violationEventAdditionalInfo?: ViolationEventAdditionalInfo;
    /**
     * <p>The type of violation event.</p>
     */
    violationEventType?: ViolationEventType | string;
    /**
     * <p>The verification state of the violation (detect alarm).</p>
     */
    verificationState?: VerificationState | string;
    /**
     * <p>The description of the verification state of the violation.</p>
     */
    verificationStateDescription?: string;
    /**
     * <p>The time the violation event occurred.</p>
     */
    violationEventTime?: Date;
}
export declare namespace ViolationEvent {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ViolationEvent) => any;
}
export interface ListViolationEventsResponse {
    /**
     * <p>The security profile violation alerts issued for this account during the given time period,
     *       potentially filtered by security profile, behavior violated, or thing (device) violating.</p>
     */
    violationEvents?: ViolationEvent[];
    /**
     * <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no
     *         additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListViolationEventsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListViolationEventsResponse) => any;
}
export interface PutVerificationStateOnViolationRequest {
    /**
     * <p>The violation ID.</p>
     */
    violationId: string | undefined;
    /**
     * <p>The verification state of the violation.</p>
     */
    verificationState: VerificationState | string | undefined;
    /**
     * <p>The description of the verification state of the violation (detect alarm).</p>
     */
    verificationStateDescription?: string;
}
export declare namespace PutVerificationStateOnViolationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: PutVerificationStateOnViolationRequest) => any;
}
export interface PutVerificationStateOnViolationResponse {
}
export declare namespace PutVerificationStateOnViolationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: PutVerificationStateOnViolationResponse) => any;
}
/**
 * <p>The input to the RegisterCACertificate operation.</p>
 */
export interface RegisterCACertificateRequest {
    /**
     * <p>The CA certificate.</p>
     */
    caCertificate: string | undefined;
    /**
     * <p>The private key verification certificate.</p>
     */
    verificationCertificate: string | undefined;
    /**
     * <p>A boolean value that specifies if the CA certificate is set to active.</p>
     */
    setAsActive?: boolean;
    /**
     * <p>Allows this CA certificate to be used for auto registration of device
     *          certificates.</p>
     */
    allowAutoRegistration?: boolean;
    /**
     * <p>Information about the registration configuration.</p>
     */
    registrationConfig?: RegistrationConfig;
    /**
     * <p>Metadata which can be used to manage the CA certificate.</p>
     *          <note>
     *             <p>For URI Request parameters use format: ...key1=value1&key2=value2...</p>
     *             <p>For the CLI command-line parameter use format: &&tags
     *             "key1=value1&key2=value2..."</p>
     *             <p>For the cli-input-json file use format: "tags":
     *             "key1=value1&key2=value2..."</p>
     *          </note>
     */
    tags?: Tag[];
}
export declare namespace RegisterCACertificateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCACertificateRequest) => any;
}
/**
 * <p>The output from the RegisterCACertificateResponse operation.</p>
 */
export interface RegisterCACertificateResponse {
    /**
     * <p>The CA certificate ARN.</p>
     */
    certificateArn?: string;
    /**
     * <p>The CA certificate identifier.</p>
     */
    certificateId?: string;
}
export declare namespace RegisterCACertificateResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCACertificateResponse) => any;
}
/**
 * <p>The registration code is invalid.</p>
 */
export interface RegistrationCodeValidationException extends __SmithyException, $MetadataBearer {
    name: "RegistrationCodeValidationException";
    $fault: "client";
    /**
     * <p>Additional information about the exception.</p>
     */
    message?: string;
}
/**
 * <p>Unable to verify the CA certificate used to sign the device certificate you are
 *          attempting to register. This is happens when you have registered more than one CA
 *          certificate that has the same subject field and public key.</p>
 */
export interface CertificateConflictException extends __SmithyException, $MetadataBearer {
    name: "CertificateConflictException";
    $fault: "client";
    /**
     * <p>The message for the exception.</p>
     */
    message?: string;
}
/**
 * <p>The input to the RegisterCertificate operation.</p>
 */
export interface RegisterCertificateRequest {
    /**
     * <p>The certificate data, in PEM format.</p>
     */
    certificatePem: string | undefined;
    /**
     * <p>The CA certificate used to sign the device certificate being registered.</p>
     */
    caCertificatePem?: string;
    /**
     * @deprecated
     *
     * <p>A boolean value that specifies if the certificate is set to active.</p>
     */
    setAsActive?: boolean;
    /**
     * <p>The status of the register certificate request.</p>
     */
    status?: CertificateStatus | string;
}
export declare namespace RegisterCertificateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCertificateRequest) => any;
}
/**
 * <p>The output from the RegisterCertificate operation.</p>
 */
export interface RegisterCertificateResponse {
    /**
     * <p>The certificate ARN.</p>
     */
    certificateArn?: string;
    /**
     * <p>The certificate identifier.</p>
     */
    certificateId?: string;
}
export declare namespace RegisterCertificateResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCertificateResponse) => any;
}
export interface RegisterCertificateWithoutCARequest {
    /**
     * <p>The certificate data, in PEM format.</p>
     */
    certificatePem: string | undefined;
    /**
     * <p>The status of the register certificate request.</p>
     */
    status?: CertificateStatus | string;
}
export declare namespace RegisterCertificateWithoutCARequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCertificateWithoutCARequest) => any;
}
export interface RegisterCertificateWithoutCAResponse {
    /**
     * <p>The Amazon Resource Name (ARN) of the registered certificate.</p>
     */
    certificateArn?: string;
    /**
     * <p>The ID of the registered certificate. (The last part of the certificate ARN contains the
     *          certificate ID.</p>
     */
    certificateId?: string;
}
export declare namespace RegisterCertificateWithoutCAResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterCertificateWithoutCAResponse) => any;
}
export interface RegisterThingRequest {
    /**
     * <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html">Provisioning Devices That Have Device Certificates</a> for more information.</p>
     */
    templateBody: string | undefined;
    /**
     * <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html">Provisioning Templates</a> for more information.</p>
     */
    parameters?: {
        [key: string]: string;
    };
}
export declare namespace RegisterThingRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterThingRequest) => any;
}
export interface RegisterThingResponse {
    /**
     * <p>The certificate data, in PEM format.</p>
     */
    certificatePem?: string;
    /**
     * <p>ARNs for the generated resources.</p>
     */
    resourceArns?: {
        [key: string]: string;
    };
}
export declare namespace RegisterThingResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RegisterThingResponse) => any;
}
/**
 * <p>The resource registration failed.</p>
 */
export interface ResourceRegistrationFailureException extends __SmithyException, $MetadataBearer {
    name: "ResourceRegistrationFailureException";
    $fault: "client";
    /**
     * <p>The message for the exception.</p>
     */
    message?: string;
}
/**
 * <p>The input for the RejectCertificateTransfer operation.</p>
 */
export interface RejectCertificateTransferRequest {
    /**
     * <p>The ID of the certificate. (The last part of the certificate ARN contains the
     *          certificate ID.)</p>
     */
    certificateId: string | undefined;
    /**
     * <p>The reason the certificate transfer was rejected.</p>
     */
    rejectReason?: string;
}
export declare namespace RejectCertificateTransferRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RejectCertificateTransferRequest) => any;
}
export interface RemoveThingFromBillingGroupRequest {
    /**
     * <p>The name of the billing group.</p>
     */
    billingGroupName?: string;
    /**
     * <p>The ARN of the billing group.</p>
     */
    billingGroupArn?: string;
    /**
     * <p>The name of the thing to be removed from the billing group.</p>
     */
    thingName?: string;
    /**
     * <p>The ARN of the thing to be removed from the billing group.</p>
     */
    thingArn?: string;
}
export declare namespace RemoveThingFromBillingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RemoveThingFromBillingGroupRequest) => any;
}
export interface RemoveThingFromBillingGroupResponse {
}
export declare namespace RemoveThingFromBillingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RemoveThingFromBillingGroupResponse) => any;
}
export interface RemoveThingFromThingGroupRequest {
    /**
     * <p>The group name.</p>
     */
    thingGroupName?: string;
    /**
     * <p>The group ARN.</p>
     */
    thingGroupArn?: string;
    /**
     * <p>The name of the thing to remove from the group.</p>
     */
    thingName?: string;
    /**
     * <p>The ARN of the thing to remove from the group.</p>
     */
    thingArn?: string;
}
export declare namespace RemoveThingFromThingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RemoveThingFromThingGroupRequest) => any;
}
export interface RemoveThingFromThingGroupResponse {
}
export declare namespace RemoveThingFromThingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RemoveThingFromThingGroupResponse) => any;
}
/**
 * <p>The input for the ReplaceTopicRule operation.</p>
 */
export interface ReplaceTopicRuleRequest {
    /**
     * <p>The name of the rule.</p>
     */
    ruleName: string | undefined;
    /**
     * <p>The rule payload.</p>
     */
    topicRulePayload: TopicRulePayload | undefined;
}
export declare namespace ReplaceTopicRuleRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ReplaceTopicRuleRequest) => any;
}
export interface SearchIndexRequest {
    /**
     * <p>The search index name.</p>
     */
    indexName?: string;
    /**
     * <p>The search query string.</p>
     */
    queryString: string | undefined;
    /**
     * <p>The token used to get the next set of results, or <code>null</code> if there are no additional
     *       results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
    /**
     * <p>The query version.</p>
     */
    queryVersion?: string;
}
export declare namespace SearchIndexRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SearchIndexRequest) => any;
}
/**
 * <p>The thing group search index document.</p>
 */
export interface ThingGroupDocument {
    /**
     * <p>The thing group name.</p>
     */
    thingGroupName?: string;
    /**
     * <p>The thing group ID.</p>
     */
    thingGroupId?: string;
    /**
     * <p>The thing group description.</p>
     */
    thingGroupDescription?: string;
    /**
     * <p>The thing group attributes.</p>
     */
    attributes?: {
        [key: string]: string;
    };
    /**
     * <p>Parent group names.</p>
     */
    parentGroupNames?: string[];
}
export declare namespace ThingGroupDocument {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ThingGroupDocument) => any;
}
/**
 * <p>The connectivity status of the thing.</p>
 */
export interface ThingConnectivity {
    /**
     * <p>True if the thing is connected to the Amazon Web Services IoT Core service; false if it is not
     *       connected.</p>
     */
    connected?: boolean;
    /**
     * <p>The epoch time (in milliseconds) when the thing last connected or disconnected. If the
     *       thing has been disconnected for approximately an hour, the time value might be missing.</p>
     */
    timestamp?: number;
    /**
     * <p>The reason why the client is disconnected. If the thing has been disconnected for approximately an hour, the <code>disconnectReason</code> value might be missing.</p>
     */
    disconnectReason?: string;
}
export declare namespace ThingConnectivity {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ThingConnectivity) => any;
}
/**
 * <p>The thing search index document.</p>
 */
export interface ThingDocument {
    /**
     * <p>The thing name.</p>
     */
    thingName?: string;
    /**
     * <p>The thing ID.</p>
     */
    thingId?: string;
    /**
     * <p>The thing type name.</p>
     */
    thingTypeName?: string;
    /**
     * <p>Thing group names.</p>
     */
    thingGroupNames?: string[];
    /**
     * <p>The attributes.</p>
     */
    attributes?: {
        [key: string]: string;
    };
    /**
     * <p>The unnamed shadow and named shadow.</p>
     *          <p>For more information about shadows, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html">IoT Device Shadow service.</a>
     *          </p>
     */
    shadow?: string;
    /**
     * <p>Contains Device Defender data.</p>
     *          <p>For more information about Device Defender, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/device-defender.html">Device Defender</a>. </p>
     */
    deviceDefender?: string;
    /**
     * <p>Indicates whether the thing is connected to the Amazon Web Services IoT Core service.</p>
     */
    connectivity?: ThingConnectivity;
}
export declare namespace ThingDocument {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ThingDocument) => any;
}
export interface SearchIndexResponse {
    /**
     * <p>The token used to get the next set of results, or <code>null</code> if there are no additional
     *       results.</p>
     */
    nextToken?: string;
    /**
     * <p>The things that match the search query.</p>
     */
    things?: ThingDocument[];
    /**
     * <p>The thing groups that match the search query.</p>
     */
    thingGroups?: ThingGroupDocument[];
}
export declare namespace SearchIndexResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SearchIndexResponse) => any;
}
export interface SetDefaultAuthorizerRequest {
    /**
     * <p>The authorizer name.</p>
     */
    authorizerName: string | undefined;
}
export declare namespace SetDefaultAuthorizerRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetDefaultAuthorizerRequest) => any;
}
export interface SetDefaultAuthorizerResponse {
    /**
     * <p>The authorizer name.</p>
     */
    authorizerName?: string;
    /**
     * <p>The authorizer ARN.</p>
     */
    authorizerArn?: string;
}
export declare namespace SetDefaultAuthorizerResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetDefaultAuthorizerResponse) => any;
}
/**
 * <p>The input for the SetDefaultPolicyVersion operation.</p>
 */
export interface SetDefaultPolicyVersionRequest {
    /**
     * <p>The policy name.</p>
     */
    policyName: string | undefined;
    /**
     * <p>The policy version ID.</p>
     */
    policyVersionId: string | undefined;
}
export declare namespace SetDefaultPolicyVersionRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetDefaultPolicyVersionRequest) => any;
}
/**
 * <p>Describes the logging options payload.</p>
 */
export interface LoggingOptionsPayload {
    /**
     * <p>The ARN of the IAM role that grants access.</p>
     */
    roleArn: string | undefined;
    /**
     * <p>The log level.</p>
     */
    logLevel?: LogLevel | string;
}
export declare namespace LoggingOptionsPayload {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: LoggingOptionsPayload) => any;
}
/**
 * <p>The input for the SetLoggingOptions operation.</p>
 */
export interface SetLoggingOptionsRequest {
    /**
     * <p>The logging options payload.</p>
     */
    loggingOptionsPayload: LoggingOptionsPayload | undefined;
}
export declare namespace SetLoggingOptionsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetLoggingOptionsRequest) => any;
}
export interface SetV2LoggingLevelRequest {
    /**
     * <p>The log target.</p>
     */
    logTarget: LogTarget | undefined;
    /**
     * <p>The log level.</p>
     */
    logLevel: LogLevel | string | undefined;
}
export declare namespace SetV2LoggingLevelRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetV2LoggingLevelRequest) => any;
}
export interface SetV2LoggingOptionsRequest {
    /**
     * <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
     */
    roleArn?: string;
    /**
     * <p>The default logging level.</p>
     */
    defaultLogLevel?: LogLevel | string;
    /**
     * <p>If true all logs are disabled. The default is false.</p>
     */
    disableAllLogs?: boolean;
}
export declare namespace SetV2LoggingOptionsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: SetV2LoggingOptionsRequest) => any;
}
export interface StartAuditMitigationActionsTaskRequest {
    /**
     * <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
     */
    taskId: string | undefined;
    /**
     * <p>Specifies the audit findings to which the mitigation actions are applied. You can apply
     *       them to a type of audit check, to all findings from an audit, or to a
     *       specific set of
     *       findings.</p>
     */
    target: AuditMitigationActionsTaskTarget | undefined;
    /**
     * <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your Amazon Web Services accounts.</p>
     */
    auditCheckToActionsMapping: {
        [key: string]: string[];
    } | undefined;
    /**
     * <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
     */
    clientRequestToken?: string;
}
export declare namespace StartAuditMitigationActionsTaskRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartAuditMitigationActionsTaskRequest) => any;
}
export interface StartAuditMitigationActionsTaskResponse {
    /**
     * <p>The unique identifier for the audit mitigation task. This matches the <code>taskId</code> that you specified in the request.</p>
     */
    taskId?: string;
}
export declare namespace StartAuditMitigationActionsTaskResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartAuditMitigationActionsTaskResponse) => any;
}
/**
 * <p>
 *             This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.
 *         </p>
 */
export interface TaskAlreadyExistsException extends __SmithyException, $MetadataBearer {
    name: "TaskAlreadyExistsException";
    $fault: "client";
    message?: string;
}
export interface StartDetectMitigationActionsTaskRequest {
    /**
     * <p>
     *       The unique identifier of the task.
     *     </p>
     */
    taskId: string | undefined;
    /**
     * <p>
     *       Specifies the ML Detect findings to which the mitigation actions are applied.
     *     </p>
     */
    target: DetectMitigationActionsTaskTarget | undefined;
    /**
     * <p>
     *       The actions to be performed when a device has unexpected behavior.
     *     </p>
     */
    actions: string[] | undefined;
    /**
     * <p>
     *       Specifies the time period of which violation events occurred between.
     *     </p>
     */
    violationEventOccurrenceRange?: ViolationEventOccurrenceRange;
    /**
     * <p>
     *       Specifies to list only active violations.
     *     </p>
     */
    includeOnlyActiveViolations?: boolean;
    /**
     * <p>
     *       Specifies to include suppressed alerts.
     *     </p>
     */
    includeSuppressedAlerts?: boolean;
    /**
     * <p>
     *       Each mitigation action task must have a unique client request token. If you try to create a new task with the same token as a task that already exists, an exception occurs. If you omit this value, Amazon Web Services SDKs will automatically generate a unique client request.
     *     </p>
     */
    clientRequestToken?: string;
}
export declare namespace StartDetectMitigationActionsTaskRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartDetectMitigationActionsTaskRequest) => any;
}
export interface StartDetectMitigationActionsTaskResponse {
    /**
     * <p>
     *       The unique identifier of the task.
     *     </p>
     */
    taskId?: string;
}
export declare namespace StartDetectMitigationActionsTaskResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartDetectMitigationActionsTaskResponse) => any;
}
export interface StartOnDemandAuditTaskRequest {
    /**
     * <p>Which checks are performed during the audit. The checks you specify must be enabled
     *             for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code>
     *             to see the list of all checks, including those that are enabled or
     *             <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
     */
    targetCheckNames: string[] | undefined;
}
export declare namespace StartOnDemandAuditTaskRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartOnDemandAuditTaskRequest) => any;
}
export interface StartOnDemandAuditTaskResponse {
    /**
     * <p>The ID of the on-demand audit you started.</p>
     */
    taskId?: string;
}
export declare namespace StartOnDemandAuditTaskResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartOnDemandAuditTaskResponse) => any;
}
export interface StartThingRegistrationTaskRequest {
    /**
     * <p>The provisioning template.</p>
     */
    templateBody: string | undefined;
    /**
     * <p>The S3 bucket that contains the input file.</p>
     */
    inputFileBucket: string | undefined;
    /**
     * <p>The name of input file within the S3 bucket. This file contains a newline delimited
     * 			JSON file. Each line contains the parameter values to provision one device
     * 			(thing).</p>
     */
    inputFileKey: string | undefined;
    /**
     * <p>The IAM role ARN that grants permission the input file.</p>
     */
    roleArn: string | undefined;
}
export declare namespace StartThingRegistrationTaskRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartThingRegistrationTaskRequest) => any;
}
export interface StartThingRegistrationTaskResponse {
    /**
     * <p>The bulk thing provisioning task ID.</p>
     */
    taskId?: string;
}
export declare namespace StartThingRegistrationTaskResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StartThingRegistrationTaskResponse) => any;
}
export interface StopThingRegistrationTaskRequest {
    /**
     * <p>The bulk thing provisioning task ID.</p>
     */
    taskId: string | undefined;
}
export declare namespace StopThingRegistrationTaskRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StopThingRegistrationTaskRequest) => any;
}
export interface StopThingRegistrationTaskResponse {
}
export declare namespace StopThingRegistrationTaskResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: StopThingRegistrationTaskResponse) => any;
}
export interface TagResourceRequest {
    /**
     * <p>The ARN of the resource.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>The new or modified tags for the resource.</p>
     */
    tags: Tag[] | undefined;
}
export declare namespace TagResourceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TagResourceRequest) => any;
}
export interface TagResourceResponse {
}
export declare namespace TagResourceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TagResourceResponse) => any;
}
export interface TestAuthorizationRequest {
    /**
     * <p>The principal. Valid principals are CertificateArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:cert/<i>certificateId</i>), thingGroupArn (arn:aws:iot:<i>region</i>:<i>accountId</i>:thinggroup/<i>groupName</i>) and CognitoId (<i>region</i>:<i>id</i>).</p>
     */
    principal?: string;
    /**
     * <p>The Cognito identity pool ID.</p>
     */
    cognitoIdentityPoolId?: string;
    /**
     * <p>A list of authorization info objects. Simulating authorization will create a response
     *          for each <code>authInfo</code> object in the list.</p>
     */
    authInfos: AuthInfo[] | undefined;
    /**
     * <p>The MQTT client ID.</p>
     */
    clientId?: string;
    /**
     * <p>When testing custom authorization, the policies specified here are treated as if they
     *          are attached to the principal being authorized.</p>
     */
    policyNamesToAdd?: string[];
    /**
     * <p>When testing custom authorization, the policies specified here are treated as if they
     *          are not attached to the principal being authorized.</p>
     */
    policyNamesToSkip?: string[];
}
export declare namespace TestAuthorizationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TestAuthorizationRequest) => any;
}
export interface TestAuthorizationResponse {
    /**
     * <p>The authentication results.</p>
     */
    authResults?: AuthResult[];
}
export declare namespace TestAuthorizationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TestAuthorizationResponse) => any;
}
/**
 * <p>The response is invalid.</p>
 */
export interface InvalidResponseException extends __SmithyException, $MetadataBearer {
    name: "InvalidResponseException";
    $fault: "client";
    /**
     * <p>The message for the exception.</p>
     */
    message?: string;
}
/**
 * <p>Specifies the HTTP context to use for the test authorizer request.</p>
 */
export interface HttpContext {
    /**
     * <p>The header keys and values in an HTTP authorization request.</p>
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * <p>The query string keys and values in an HTTP authorization request.</p>
     */
    queryString?: string;
}
export declare namespace HttpContext {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: HttpContext) => any;
}
/**
 * <p>Specifies the MQTT context to use for the test authorizer request</p>
 */
export interface MqttContext {
    /**
     * <p>The value of the <code>username</code> key in an MQTT authorization request.</p>
     */
    username?: string;
    /**
     * <p>The value of the <code>password</code> key in an MQTT authorization request.</p>
     */
    password?: Uint8Array;
    /**
     * <p>The value of the <code>clientId</code> key in an MQTT authorization request.</p>
     */
    clientId?: string;
}
export declare namespace MqttContext {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: MqttContext) => any;
}
/**
 * <p>Specifies the TLS context to use for the test authorizer request.</p>
 */
export interface TlsContext {
    /**
     * <p>The value of the <code>serverName</code> key in a TLS authorization request.</p>
     */
    serverName?: string;
}
export declare namespace TlsContext {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TlsContext) => any;
}
export interface TestInvokeAuthorizerRequest {
    /**
     * <p>The custom authorizer name.</p>
     */
    authorizerName: string | undefined;
    /**
     * <p>The token returned by your custom authentication service.</p>
     */
    token?: string;
    /**
     * <p>The signature made with the token and your custom authentication service's private
     *          key. This value must be Base-64-encoded.</p>
     */
    tokenSignature?: string;
    /**
     * <p>Specifies a test HTTP authorization request.</p>
     */
    httpContext?: HttpContext;
    /**
     * <p>Specifies a test MQTT authorization request.</p>
     */
    mqttContext?: MqttContext;
    /**
     * <p>Specifies a test TLS authorization request.</p>
     */
    tlsContext?: TlsContext;
}
export declare namespace TestInvokeAuthorizerRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TestInvokeAuthorizerRequest) => any;
}
export interface TestInvokeAuthorizerResponse {
    /**
     * <p>True if the token is authenticated, otherwise false.</p>
     */
    isAuthenticated?: boolean;
    /**
     * <p>The principal ID.</p>
     */
    principalId?: string;
    /**
     * <p>IAM policy documents.</p>
     */
    policyDocuments?: string[];
    /**
     * <p>The number of seconds after which the temporary credentials are refreshed.</p>
     */
    refreshAfterInSeconds?: number;
    /**
     * <p>The number of seconds after which the connection is terminated.</p>
     */
    disconnectAfterInSeconds?: number;
}
export declare namespace TestInvokeAuthorizerResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TestInvokeAuthorizerResponse) => any;
}
/**
 * <p>The input for the TransferCertificate operation.</p>
 */
export interface TransferCertificateRequest {
    /**
     * <p>The ID of the certificate. (The last part of the certificate ARN contains the
     *          certificate ID.)</p>
     */
    certificateId: string | undefined;
    /**
     * <p>The Amazon Web Services account.</p>
     */
    targetAwsAccount: string | undefined;
    /**
     * <p>The transfer message.</p>
     */
    transferMessage?: string;
}
export declare namespace TransferCertificateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TransferCertificateRequest) => any;
}
/**
 * <p>The output from the TransferCertificate operation.</p>
 */
export interface TransferCertificateResponse {
    /**
     * <p>The ARN of the certificate.</p>
     */
    transferredCertificateArn?: string;
}
export declare namespace TransferCertificateResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TransferCertificateResponse) => any;
}
/**
 * <p>You can't transfer the certificate because authorization policies are still
 *          attached.</p>
 */
export interface TransferConflictException extends __SmithyException, $MetadataBearer {
    name: "TransferConflictException";
    $fault: "client";
    /**
     * <p>The message for the exception.</p>
     */
    message?: string;
}
export interface UntagResourceRequest {
    /**
     * <p>The ARN of the resource.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>A list of the keys of the tags to be removed from the resource.</p>
     */
    tagKeys: string[] | undefined;
}
export declare namespace UntagResourceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UntagResourceRequest) => any;
}
export interface UntagResourceResponse {
}
export declare namespace UntagResourceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UntagResourceResponse) => any;
}
export interface UpdateAccountAuditConfigurationRequest {
    /**
     * <p>The Amazon
     *       Resource Name
     *       (ARN)
     *       of the role that grants permission
     *       to
     *       IoT to access information about your devices, policies,
     *       certificates,
     *       and other items as required when performing an audit.</p>
     */
    roleArn?: string;
    /**
     * <p>Information about the targets to which audit notifications are sent.</p>
     */
    auditNotificationTargetConfigurations?: {
        [key: string]: AuditNotificationTarget;
    };
    /**
     * <p>Specifies which audit checks are enabled and disabled for this account. Use
     *             <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those
     *             that are currently enabled.</p>
     *           <p>Some data collection might start immediately when certain checks are enabled.
     *             When a check is disabled, any data collected so far in relation to the check is deleted.</p>
     *           <p>You
     *       cannot
     *       disable a check if
     *       it's
     *       used by any scheduled audit. You must first delete the check from the scheduled audit or
     *       delete the scheduled audit itself.</p>
     *           <p>On the first call to <code>UpdateAccountAuditConfiguration</code>,
     *             this parameter is required and must specify at least one enabled check.</p>
     */
    auditCheckConfigurations?: {
        [key: string]: AuditCheckConfiguration;
    };
}
export declare namespace UpdateAccountAuditConfigurationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAccountAuditConfigurationRequest) => any;
}
export interface UpdateAccountAuditConfigurationResponse {
}
export declare namespace UpdateAccountAuditConfigurationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAccountAuditConfigurationResponse) => any;
}
export interface UpdateAuditSuppressionRequest {
    /**
     * <p>An audit check name. Checks must be enabled
     *         for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
     *         of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
     *         to select which checks are enabled.)</p>
     */
    checkName: string | undefined;
    /**
     * <p>Information that identifies the noncompliant resource.</p>
     */
    resourceIdentifier: ResourceIdentifier | undefined;
    /**
     * <p>
     *       The expiration date (epoch timestamp in seconds) that you want the suppression to adhere to.
     *     </p>
     */
    expirationDate?: Date;
    /**
     * <p>
     *       Indicates whether a suppression should exist indefinitely or not.
     *     </p>
     */
    suppressIndefinitely?: boolean;
    /**
     * <p>
     *       The description of the audit suppression.
     *     </p>
     */
    description?: string;
}
export declare namespace UpdateAuditSuppressionRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAuditSuppressionRequest) => any;
}
export interface UpdateAuditSuppressionResponse {
}
export declare namespace UpdateAuditSuppressionResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAuditSuppressionResponse) => any;
}
export interface UpdateAuthorizerRequest {
    /**
     * <p>The authorizer name.</p>
     */
    authorizerName: string | undefined;
    /**
     * <p>The ARN of the authorizer's Lambda function.</p>
     */
    authorizerFunctionArn?: string;
    /**
     * <p>The key used to extract the token from the HTTP headers. </p>
     */
    tokenKeyName?: string;
    /**
     * <p>The public keys used to verify the token signature.</p>
     */
    tokenSigningPublicKeys?: {
        [key: string]: string;
    };
    /**
     * <p>The status of the update authorizer request.</p>
     */
    status?: AuthorizerStatus | string;
    /**
     * <p>When <code>true</code>, the result from the authorizer’s Lambda function is
     * 	  cached for the time specified in <code>refreshAfterInSeconds</code>. The cached
     * 	  result is used while the device reuses the same HTTP connection.</p>
     */
    enableCachingForHttp?: boolean;
}
export declare namespace UpdateAuthorizerRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAuthorizerRequest) => any;
}
export interface UpdateAuthorizerResponse {
    /**
     * <p>The authorizer name.</p>
     */
    authorizerName?: string;
    /**
     * <p>The authorizer ARN.</p>
     */
    authorizerArn?: string;
}
export declare namespace UpdateAuthorizerResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateAuthorizerResponse) => any;
}
export interface UpdateBillingGroupRequest {
    /**
     * <p>The name of the billing group.</p>
     */
    billingGroupName: string | undefined;
    /**
     * <p>The properties of the billing group.</p>
     */
    billingGroupProperties: BillingGroupProperties | undefined;
    /**
     * <p>The expected version of the billing group. If the version of the billing group does
     * 			not match the expected version specified in the request, the
     * 				<code>UpdateBillingGroup</code> request is rejected with a
     * 				<code>VersionConflictException</code>.</p>
     */
    expectedVersion?: number;
}
export declare namespace UpdateBillingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateBillingGroupRequest) => any;
}
export interface UpdateBillingGroupResponse {
    /**
     * <p>The latest version of the billing group.</p>
     */
    version?: number;
}
export declare namespace UpdateBillingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateBillingGroupResponse) => any;
}
/**
 * <p>The input to the UpdateCACertificate operation.</p>
 */
export interface UpdateCACertificateRequest {
    /**
     * <p>The CA certificate identifier.</p>
     */
    certificateId: string | undefined;
    /**
     * <p>The updated status of the CA certificate.</p>
     *          <p>
     *             <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
     *          should not be used.</p>
     */
    newStatus?: CACertificateStatus | string;
    /**
     * <p>The new value for the auto registration status. Valid values are: "ENABLE" or
     *          "DISABLE".</p>
     */
    newAutoRegistrationStatus?: AutoRegistrationStatus | string;
    /**
     * <p>Information about the registration configuration.</p>
     */
    registrationConfig?: RegistrationConfig;
    /**
     * <p>If true, removes auto registration.</p>
     */
    removeAutoRegistration?: boolean;
}
export declare namespace UpdateCACertificateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateCACertificateRequest) => any;
}
/**
 * <p>The input for the UpdateCertificate operation.</p>
 */
export interface UpdateCertificateRequest {
    /**
     * <p>The ID of the certificate. (The last part of the certificate ARN contains the
     *          certificate ID.)</p>
     */
    certificateId: string | undefined;
    /**
     * <p>The new status.</p>
     *          <p>
     *             <b>Note:</b> Setting the status to PENDING_TRANSFER  or PENDING_ACTIVATION will result
     *          in an exception being thrown. PENDING_TRANSFER and PENDING_ACTIVATION are statuses used internally by IoT. They
     *          are not intended for developer use.</p>
     *          <p>
     *             <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and
     *          should not be used.</p>
     */
    newStatus: CertificateStatus | string | undefined;
}
export declare namespace UpdateCertificateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateCertificateRequest) => any;
}
export interface UpdateCustomMetricRequest {
    /**
     * <p> The name of the custom metric.
     *       Cannot be updated. </p>
     */
    metricName: string | undefined;
    /**
     * <p>
     *       Field
     *       represents a friendly name in the console for the custom metric,
     *       it
     *       doesn't have to be unique. Don't use this name as the metric identifier in
     *       the device metric report.
     *       Can
     *       be updated. </p>
     */
    displayName: string | undefined;
}
export declare namespace UpdateCustomMetricRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateCustomMetricRequest) => any;
}
export interface UpdateCustomMetricResponse {
    /**
     * <p>
     *       The name of the custom metric.
     *     </p>
     */
    metricName?: string;
    /**
     * <p>
     *       The Amazon Resource Number (ARN) of the custom metric.
     *     </p>
     */
    metricArn?: string;
    /**
     * <p>
     *       The type of the custom metric. Types include <code>string-list</code>, <code>ip-address-list</code>, <code>number-list</code>, and <code>number</code>.
     *     </p>
     */
    metricType?: CustomMetricType | string;
    /**
     * <p>
     *       A friendly name in the console for the custom metric
     *     </p>
     */
    displayName?: string;
    /**
     * <p>
     *       The creation date of the custom metric in milliseconds since epoch.
     *     </p>
     */
    creationDate?: Date;
    /**
     * <p>
     *       The time the custom metric was last modified in milliseconds since epoch.
     *     </p>
     */
    lastModifiedDate?: Date;
}
export declare namespace UpdateCustomMetricResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateCustomMetricResponse) => any;
}
export interface UpdateDimensionRequest {
    /**
     * <p>A unique identifier for the dimension. Choose something that describes the type and value to make it easy to remember what it does.</p>
     */
    name: string | undefined;
    /**
     * <p>Specifies the value or list of values for the dimension. For <code>TOPIC_FILTER</code> dimensions, this is a pattern used to match the MQTT topic (for example, "admin/#").</p>
     */
    stringValues: string[] | undefined;
}
export declare namespace UpdateDimensionRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDimensionRequest) => any;
}
export interface UpdateDimensionResponse {
    /**
     * <p>A unique identifier for the dimension.</p>
     */
    name?: string;
    /**
     * <p>The Amazon Resource
     *       Name (ARN)of
     *       the created dimension.</p>
     */
    arn?: string;
    /**
     * <p>The type of the dimension.</p>
     */
    type?: DimensionType | string;
    /**
     * <p>The value or list of values used to scope the dimension. For example, for topic filters, this is the pattern used to match the MQTT topic name.</p>
     */
    stringValues?: string[];
    /**
     * <p>The date and time, in milliseconds since epoch, when the dimension was initially created.</p>
     */
    creationDate?: Date;
    /**
     * <p>The date and time, in milliseconds since epoch, when the dimension was most recently updated.</p>
     */
    lastModifiedDate?: Date;
}
export declare namespace UpdateDimensionResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDimensionResponse) => any;
}
export interface UpdateDomainConfigurationRequest {
    /**
     * <p>The name of the domain configuration to be updated.</p>
     */
    domainConfigurationName: string | undefined;
    /**
     * <p>An object that specifies the authorization service for a domain.</p>
     */
    authorizerConfig?: AuthorizerConfig;
    /**
     * <p>The status to which the domain configuration should be updated.</p>
     */
    domainConfigurationStatus?: DomainConfigurationStatus | string;
    /**
     * <p>Removes the authorization configuration from a domain.</p>
     */
    removeAuthorizerConfig?: boolean;
}
export declare namespace UpdateDomainConfigurationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDomainConfigurationRequest) => any;
}
export interface UpdateDomainConfigurationResponse {
    /**
     * <p>The name of the domain configuration that was updated.</p>
     */
    domainConfigurationName?: string;
    /**
     * <p>The ARN of the domain configuration that was updated.</p>
     */
    domainConfigurationArn?: string;
}
export declare namespace UpdateDomainConfigurationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDomainConfigurationResponse) => any;
}
export interface UpdateDynamicThingGroupRequest {
    /**
     * <p>The name of the dynamic thing group to update.</p>
     */
    thingGroupName: string | undefined;
    /**
     * <p>The dynamic thing group properties to update.</p>
     */
    thingGroupProperties: ThingGroupProperties | undefined;
    /**
     * <p>The expected version of the dynamic thing group to update.</p>
     */
    expectedVersion?: number;
    /**
     * <p>The dynamic thing group index to update.</p>
     * 		       <note>
     * 			         <p>Currently one index is supported: <code>AWS_Things</code>.</p>
     * 		       </note>
     */
    indexName?: string;
    /**
     * <p>The dynamic thing group search query string to update.</p>
     */
    queryString?: string;
    /**
     * <p>The dynamic thing group query version to update.</p>
     * 		       <note>
     * 			         <p>Currently one query version is supported: "2017-09-30". If not specified, the
     * 				query version defaults to this value.</p>
     * 		       </note>
     */
    queryVersion?: string;
}
export declare namespace UpdateDynamicThingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDynamicThingGroupRequest) => any;
}
export interface UpdateDynamicThingGroupResponse {
    /**
     * <p>The dynamic thing group version.</p>
     */
    version?: number;
}
export declare namespace UpdateDynamicThingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateDynamicThingGroupResponse) => any;
}
export interface UpdateEventConfigurationsRequest {
    /**
     * <p>The new event configuration values.</p>
     */
    eventConfigurations?: {
        [key: string]: Configuration;
    };
}
export declare namespace UpdateEventConfigurationsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateEventConfigurationsRequest) => any;
}
export interface UpdateEventConfigurationsResponse {
}
export declare namespace UpdateEventConfigurationsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateEventConfigurationsResponse) => any;
}
export interface UpdateFleetMetricRequest {
    /**
     * <p>The name of the fleet metric to update.</p>
     */
    metricName: string | undefined;
    /**
     * <p>The search query string.</p>
     */
    queryString?: string;
    /**
     * <p>The type of the aggregation query.</p>
     */
    aggregationType?: AggregationType;
    /**
     * <p>The time in seconds between fleet metric emissions. Range [60(1 min), 86400(1 day)] and must be multiple of 60.</p>
     */
    period?: number;
    /**
     * <p>The field to aggregate.</p>
     */
    aggregationField?: string;
    /**
     * <p>The description of the fleet metric.</p>
     */
    description?: string;
    /**
     * <p>The version of the query.</p>
     */
    queryVersion?: string;
    /**
     * <p>The name of the index to search.</p>
     */
    indexName: string | undefined;
    /**
     * <p>Used to support unit transformation such as milliseconds to seconds. The unit must be
     *       supported by <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">CW metric</a>.</p>
     */
    unit?: FleetMetricUnit | string;
    /**
     * <p>The expected version of the fleet metric record in the registry.</p>
     */
    expectedVersion?: number;
}
export declare namespace UpdateFleetMetricRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateFleetMetricRequest) => any;
}
export interface UpdateIndexingConfigurationRequest {
    /**
     * <p>Thing indexing configuration.</p>
     */
    thingIndexingConfiguration?: ThingIndexingConfiguration;
    /**
     * <p>Thing group indexing configuration.</p>
     */
    thingGroupIndexingConfiguration?: ThingGroupIndexingConfiguration;
}
export declare namespace UpdateIndexingConfigurationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateIndexingConfigurationRequest) => any;
}
export interface UpdateIndexingConfigurationResponse {
}
export declare namespace UpdateIndexingConfigurationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateIndexingConfigurationResponse) => any;
}
export interface UpdateJobRequest {
    /**
     * <p>The ID of the job to be updated.</p>
     */
    jobId: string | undefined;
    /**
     * <p>A short text description of the job.</p>
     */
    description?: string;
    /**
     * <p>Configuration information for pre-signed S3 URLs.</p>
     */
    presignedUrlConfig?: PresignedUrlConfig;
    /**
     * <p>Allows you to create a staged rollout of the job.</p>
     */
    jobExecutionsRolloutConfig?: JobExecutionsRolloutConfig;
    /**
     * <p>Allows you to create criteria to abort a job.</p>
     */
    abortConfig?: AbortConfig;
    /**
     * <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>.
     *             If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
     */
    timeoutConfig?: TimeoutConfig;
    /**
     * <p>The namespace used to indicate that a job is a customer-managed job.</p>
     *         <p>When you specify a value for this parameter, Amazon Web Services IoT Core sends jobs notifications to MQTT topics that
     *             contain the value in the following format.</p>
     *         <p>
     *             <code>$aws/things/<i>THING_NAME</i>/jobs/<i>JOB_ID</i>/notify-namespace-<i>NAMESPACE_ID</i>/</code>
     *          </p>
     *         <note>
     *             <p>The <code>namespaceId</code> feature is in public preview.</p>
     *          </note>
     */
    namespaceId?: string;
    /**
     * <p>Allows you to create the criteria to retry a job.</p>
     */
    jobExecutionsRetryConfig?: JobExecutionsRetryConfig;
}
export declare namespace UpdateJobRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateJobRequest) => any;
}
export interface UpdateMitigationActionRequest {
    /**
     * <p>The friendly name for the mitigation action. You cannot change the name by using
     *         <code>UpdateMitigationAction</code>. Instead, you must delete and
     *       recreate the
     *       mitigation action with the new name.</p>
     */
    actionName: string | undefined;
    /**
     * <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
     */
    roleArn?: string;
    /**
     * <p>Defines the type of action and the parameters for that action.</p>
     */
    actionParams?: MitigationActionParams;
}
export declare namespace UpdateMitigationActionRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateMitigationActionRequest) => any;
}
export interface UpdateMitigationActionResponse {
    /**
     * <p>The ARN for the new mitigation action.</p>
     */
    actionArn?: string;
    /**
     * <p>A unique identifier for the mitigation action.</p>
     */
    actionId?: string;
}
export declare namespace UpdateMitigationActionResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateMitigationActionResponse) => any;
}
export interface UpdateProvisioningTemplateRequest {
    /**
     * <p>The name of the fleet provisioning template.</p>
     */
    templateName: string | undefined;
    /**
     * <p>The description of the fleet provisioning template.</p>
     */
    description?: string;
    /**
     * <p>True to enable the fleet provisioning template, otherwise false.</p>
     */
    enabled?: boolean;
    /**
     * <p>The ID of the default provisioning template version.</p>
     */
    defaultVersionId?: number;
    /**
     * <p>The ARN of the role associated with the provisioning template. This IoT role grants
     *          permission to provision a device.</p>
     */
    provisioningRoleArn?: string;
    /**
     * <p>Updates the pre-provisioning hook template.</p>
     */
    preProvisioningHook?: ProvisioningHook;
    /**
     * <p>Removes pre-provisioning hook template.</p>
     */
    removePreProvisioningHook?: boolean;
}
export declare namespace UpdateProvisioningTemplateRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateProvisioningTemplateRequest) => any;
}
export interface UpdateProvisioningTemplateResponse {
}
export declare namespace UpdateProvisioningTemplateResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateProvisioningTemplateResponse) => any;
}
export interface UpdateRoleAliasRequest {
    /**
     * <p>The role alias to update.</p>
     */
    roleAlias: string | undefined;
    /**
     * <p>The role ARN.</p>
     */
    roleArn?: string;
    /**
     * <p>The number of seconds the credential will be valid.</p>
     */
    credentialDurationSeconds?: number;
}
export declare namespace UpdateRoleAliasRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateRoleAliasRequest) => any;
}
export interface UpdateRoleAliasResponse {
    /**
     * <p>The role alias.</p>
     */
    roleAlias?: string;
    /**
     * <p>The role alias ARN.</p>
     */
    roleAliasArn?: string;
}
export declare namespace UpdateRoleAliasResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateRoleAliasResponse) => any;
}
export interface UpdateScheduledAuditRequest {
    /**
     * <p>How often the scheduled audit takes
     *       place,
     *       either <code>DAILY</code>,
     *       <code>WEEKLY</code>, <code>BIWEEKLY</code>, or <code>MONTHLY</code>. The start time of each audit is determined by the
     *       system.</p>
     */
    frequency?: AuditFrequency | string;
    /**
     * <p>The day of the month on which the scheduled audit takes place.
     *       This
     *       can
     *       be <code>1</code> through <code>31</code> or <code>LAST</code>. This field is required if the <code>frequency</code> parameter is set to
     *             <code>MONTHLY</code>. If days 29-31 are specified, and the month does not have that many days, the audit
     *       takes place on the "LAST" day of the month.</p>
     */
    dayOfMonth?: string;
    /**
     * <p>The day of the week on which the scheduled audit takes place.
     *       This
     *       can
     *       be one of <code>SUN</code>, <code>MON</code>, <code>TUE</code>, <code>WED</code>, <code>THU</code>, <code>FRI</code>, or <code>SAT</code>. This field is required if the
     *             "frequency" parameter is set to <code>WEEKLY</code> or <code>BIWEEKLY</code>.</p>
     */
    dayOfWeek?: DayOfWeek | string;
    /**
     * <p>Which checks are performed during the scheduled audit. Checks must be enabled
     *             for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list
     *             of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code>
     *             to select which checks are enabled.)</p>
     */
    targetCheckNames?: string[];
    /**
     * <p>The name of the scheduled audit. (Max. 128 chars)</p>
     */
    scheduledAuditName: string | undefined;
}
export declare namespace UpdateScheduledAuditRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateScheduledAuditRequest) => any;
}
export interface UpdateScheduledAuditResponse {
    /**
     * <p>The ARN of the scheduled audit.</p>
     */
    scheduledAuditArn?: string;
}
export declare namespace UpdateScheduledAuditResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateScheduledAuditResponse) => any;
}
export interface UpdateSecurityProfileRequest {
    /**
     * <p>The name of the security profile you want to update.</p>
     */
    securityProfileName: string | undefined;
    /**
     * <p>A description of the security profile.</p>
     */
    securityProfileDescription?: string;
    /**
     * <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
     */
    behaviors?: Behavior[];
    /**
     * <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
     */
    alertTargets?: {
        [key: string]: AlertTarget;
    };
    /**
     * @deprecated
     *
     * <p>
     *             <i>Please use
     *           <a>UpdateSecurityProfileRequest$additionalMetricsToRetainV2</a>
     *         instead.</i>
     *          </p>
     *          <p>A list of metrics
     *      whose data is retained (stored). By default, data is retained for any metric
     *       used in the profile's <code>behaviors</code>, but
     *       it is
     *       also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
     */
    additionalMetricsToRetain?: string[];
    /**
     * <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
     */
    additionalMetricsToRetainV2?: MetricToRetain[];
    /**
     * <p>If true, delete all <code>behaviors</code> defined for this security profile.
     *         If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
     */
    deleteBehaviors?: boolean;
    /**
     * <p>If true, delete all <code>alertTargets</code> defined for this security profile.
     *         If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
     */
    deleteAlertTargets?: boolean;
    /**
     * <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this
     *         security profile. If any <code>additionalMetricsToRetain</code> are defined in the current
     *         invocation, an exception occurs.</p>
     */
    deleteAdditionalMetricsToRetain?: boolean;
    /**
     * <p>The expected version of the security profile. A new version is generated whenever
     *         the security profile is updated. If you specify a value that is different from the actual
     *         version, a <code>VersionConflictException</code> is thrown.</p>
     */
    expectedVersion?: number;
}
export declare namespace UpdateSecurityProfileRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateSecurityProfileRequest) => any;
}
export interface UpdateSecurityProfileResponse {
    /**
     * <p>The name of the security profile that was updated.</p>
     */
    securityProfileName?: string;
    /**
     * <p>The ARN of the security profile that was updated.</p>
     */
    securityProfileArn?: string;
    /**
     * <p>The description of the security profile.</p>
     */
    securityProfileDescription?: string;
    /**
     * <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
     */
    behaviors?: Behavior[];
    /**
     * <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
     */
    alertTargets?: {
        [key: string]: AlertTarget;
    };
    /**
     * @deprecated
     *
     * <p>
     *             <i>Please use
     *           <a>UpdateSecurityProfileResponse$additionalMetricsToRetainV2</a>
     *         instead.</i>
     *          </p>
     *          <p>A list of metrics
     *       whose data is retained (stored). By default, data is retained for any metric
     *       used in the security profile's <code>behaviors</code>, but
     *       it is
     *       also retained for any metric specified here.</p>
     */
    additionalMetricsToRetain?: string[];
    /**
     * <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's behaviors, but it is also retained for any metric specified here. Can be used with custom metrics; cannot be used with dimensions.</p>
     */
    additionalMetricsToRetainV2?: MetricToRetain[];
    /**
     * <p>The updated version of the security profile.</p>
     */
    version?: number;
    /**
     * <p>The time the security profile was created.</p>
     */
    creationDate?: Date;
    /**
     * <p>The time the security profile was last modified.</p>
     */
    lastModifiedDate?: Date;
}
export declare namespace UpdateSecurityProfileResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateSecurityProfileResponse) => any;
}
export interface UpdateStreamRequest {
    /**
     * <p>The stream ID.</p>
     */
    streamId: string | undefined;
    /**
     * <p>The description of the stream.</p>
     */
    description?: string;
    /**
     * <p>The files associated with the stream.</p>
     */
    files?: StreamFile[];
    /**
     * <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
     */
    roleArn?: string;
}
export declare namespace UpdateStreamRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateStreamRequest) => any;
}
export interface UpdateStreamResponse {
    /**
     * <p>The stream ID.</p>
     */
    streamId?: string;
    /**
     * <p>The stream ARN.</p>
     */
    streamArn?: string;
    /**
     * <p>A description of the stream.</p>
     */
    description?: string;
    /**
     * <p>The stream version.</p>
     */
    streamVersion?: number;
}
export declare namespace UpdateStreamResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateStreamResponse) => any;
}
/**
 * <p>The input for the UpdateThing operation.</p>
 */
export interface UpdateThingRequest {
    /**
     * <p>The name of the thing to update.</p>
     * 		       <p>You can't change a thing's name. To change a thing's name, you must create a
     * 			new thing, give it the new name, and then delete the old thing.</p>
     */
    thingName: string | undefined;
    /**
     * <p>The name of the thing type.</p>
     */
    thingTypeName?: string;
    /**
     * <p>A list of thing attributes, a JSON string containing name-value pairs. For
     * 			example:</p>
     * 		       <p>
     * 			         <code>{\"attributes\":{\"name1\":\"value2\"}}</code>
     * 		       </p>
     * 		       <p>This data is used to add new attributes or update existing attributes.</p>
     */
    attributePayload?: AttributePayload;
    /**
     * <p>The expected version of the thing record in the registry. If the version of the
     * 			record in the registry does not match the expected version specified in the request, the
     * 				<code>UpdateThing</code> request is rejected with a
     * 				<code>VersionConflictException</code>.</p>
     */
    expectedVersion?: number;
    /**
     * <p>Remove a thing type association. If <b>true</b>, the
     * 			association is removed.</p>
     */
    removeThingType?: boolean;
}
export declare namespace UpdateThingRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingRequest) => any;
}
/**
 * <p>The output from the UpdateThing operation.</p>
 */
export interface UpdateThingResponse {
}
export declare namespace UpdateThingResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingResponse) => any;
}
export interface UpdateThingGroupRequest {
    /**
     * <p>The thing group to update.</p>
     */
    thingGroupName: string | undefined;
    /**
     * <p>The thing group properties.</p>
     */
    thingGroupProperties: ThingGroupProperties | undefined;
    /**
     * <p>The expected version of the thing group. If this does not match the version of the
     * 			thing group being updated, the update will fail.</p>
     */
    expectedVersion?: number;
}
export declare namespace UpdateThingGroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingGroupRequest) => any;
}
export interface UpdateThingGroupResponse {
    /**
     * <p>The version of the updated thing group.</p>
     */
    version?: number;
}
export declare namespace UpdateThingGroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingGroupResponse) => any;
}
export interface UpdateThingGroupsForThingRequest {
    /**
     * <p>The thing whose group memberships will be updated.</p>
     */
    thingName?: string;
    /**
     * <p>The groups to which the thing will be added.</p>
     */
    thingGroupsToAdd?: string[];
    /**
     * <p>The groups from which the thing will be removed.</p>
     */
    thingGroupsToRemove?: string[];
    /**
     * <p>Override dynamic thing groups with static thing groups when 10-group limit is
     * 			reached. If a thing belongs to 10 thing groups, and one or more of those groups are
     * 			dynamic thing groups, adding a thing to a static group removes the thing from the last
     * 			dynamic group.</p>
     */
    overrideDynamicGroups?: boolean;
}
export declare namespace UpdateThingGroupsForThingRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingGroupsForThingRequest) => any;
}
export interface UpdateThingGroupsForThingResponse {
}
export declare namespace UpdateThingGroupsForThingResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingGroupsForThingResponse) => any;
}
export interface UpdateTopicRuleDestinationRequest {
    /**
     * <p>The ARN of the topic rule destination.</p>
     */
    arn: string | undefined;
    /**
     * <p>The status of the topic rule destination. Valid values are:</p>
     *          <dl>
     *             <dt>IN_PROGRESS</dt>
     *             <dd>
     *                <p>A topic rule destination was created but has not been confirmed. You can set
     *                      <code>status</code> to <code>IN_PROGRESS</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>. Calling
     *                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
     *                   be sent to your confirmation endpoint.</p>
     *             </dd>
     *             <dt>ENABLED</dt>
     *             <dd>
     *                <p>Confirmation was completed, and traffic to this destination is allowed. You can
     *                   set <code>status</code> to <code>DISABLED</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>.</p>
     *             </dd>
     *             <dt>DISABLED</dt>
     *             <dd>
     *                <p>Confirmation was completed, and traffic to this destination is not allowed. You
     *                   can set <code>status</code> to <code>ENABLED</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>.</p>
     *             </dd>
     *             <dt>ERROR</dt>
     *             <dd>
     *                <p>Confirmation could not be completed, for example if the confirmation timed out.
     *                   You can call <code>GetTopicRuleDestination</code> for details about the error. You
     *                   can set <code>status</code> to <code>IN_PROGRESS</code> by calling
     *                      <code>UpdateTopicRuleDestination</code>. Calling
     *                      <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to
     *                   be sent to your confirmation endpoint.</p>
     *             </dd>
     *          </dl>
     */
    status: TopicRuleDestinationStatus | string | undefined;
}
export declare namespace UpdateTopicRuleDestinationRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateTopicRuleDestinationRequest) => any;
}
export interface UpdateTopicRuleDestinationResponse {
}
export declare namespace UpdateTopicRuleDestinationResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateTopicRuleDestinationResponse) => any;
}
export interface ValidateSecurityProfileBehaviorsRequest {
    /**
     * <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
     */
    behaviors: Behavior[] | undefined;
}
export declare namespace ValidateSecurityProfileBehaviorsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ValidateSecurityProfileBehaviorsRequest) => any;
}
/**
 * <p>Information about an error found in a behavior specification.</p>
 */
export interface ValidationError {
    /**
     * <p>The description of an error found in the behaviors.</p>
     */
    errorMessage?: string;
}
export declare namespace ValidationError {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ValidationError) => any;
}
export interface ValidateSecurityProfileBehaviorsResponse {
    /**
     * <p>True if the behaviors were valid.</p>
     */
    valid?: boolean;
    /**
     * <p>The list of any errors found in the behaviors.</p>
     */
    validationErrors?: ValidationError[];
}
export declare namespace ValidateSecurityProfileBehaviorsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ValidateSecurityProfileBehaviorsResponse) => any;
}
